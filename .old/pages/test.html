<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width,initial-scale=1" />
	<title>BuildLab 360 — Test Viewer</title>
	<script type="module" src="https://unpkg.com/@google/model-viewer/dist/model-viewer.min.js"></script>
	<!-- Google Fonts -->
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link href="https://fonts.googleapis.com/css2?family=Arimo:wght@400;600;700&display=swap" rel="stylesheet">
	<link rel="stylesheet" href="/frontend/styles.css">
	<link rel="stylesheet" href="/frontend/viewport.css">
</head>
<body>
	<div class="container">
		<h1>Test Viewer</h1>
		<div class="controls">
			<label for="model-select">Model:</label>
			<select id="model-select">
				<option value="/model/model.glb">model.glb</option>
				<option value="/model/model-large.glb">model-large.glb</option>
			</select>

			<!-- Cached status indicator for selected model -->
			<span id="cache-indicator" title="Cached status" style="margin-left:8px; font-size:1.1rem">⚪</span>

			<button id="download-btn">Download for offline use</button>
			<button id="remove-btn" style="display:none;">Remove downloaded</button>

			<!-- Caching status text, spinner and small progress (for downloads) -->
			<span id="cache-status" style="margin-left:8px;color:#bbb;">Not downloaded</span>
			<span id="cache-spinner" style="display:none;margin-left:6px;"><span class="spinner" aria-hidden="true"></span></span>

			<div style="margin-left:auto; display:flex; gap:12px; align-items:center;">
				<!-- FPS overlay moved into the viewer; control readout removed to avoid duplication -->
			</div>
		</div>

		<!-- Per-model cached status list -->
		<div style="margin-top:8px; color:#bbb;">
			<strong>Offline status:</strong>
			<ul id="cached-list" style="list-style:none; padding:6px 0 0 0; margin:0;">
				<li data-url="/model/model.glb">model.glb — <span class="status">⚪</span></li>
				<li data-url="/model/model-large.glb">model-large.glb — <span class="status">⚪</span></li>
			</ul>
		</div>

		<div class="viewer-wrap">
			<model-viewer id="mv" src="/model/model.glb" alt="3D Model" camera-controls auto-rotate exposure="1" shadow-intensity="1"></model-viewer>
			<!-- FPS overlay displayed over the viewport (bottom-right) -->
			<div class="fps-overlay" id="fps-overlay" aria-hidden="true">FPS: <span id="fps-overlay-value">0</span></div>
		</div>

		<div class="progress" aria-hidden="false">
			<div class="bar" aria-hidden="false"><span id="bar-fill"></span></div>
			<div class="progress-meta"><div id="progress-text">Waiting to load...</div><div id="progress-percent">0%</div></div>
		</div>
	</div>

	<script>
		const mv = document.getElementById('mv');
		const barFill = document.getElementById('bar-fill');
		const progressText = document.getElementById('progress-text');
		const progressPercent = document.getElementById('progress-percent');
		const modelSelect = document.getElementById('model-select');
		const downloadBtn = document.getElementById('download-btn');
		const removeBtn = document.getElementById('remove-btn');
	const fpsOverlayEl = document.getElementById('fps-overlay-value');

		// Update progress from model-viewer events
		mv.addEventListener('progress', (e) => {
			const p = e.detail.totalProgress || 0;
			const percent = Math.round(p * 100);
			barFill.style.width = percent + '%';
			progressPercent.textContent = percent + '%';
			progressText.textContent = percent < 100 ? 'Loading...' : 'Loaded';
		});

		// Handle model changes from dropdown
		modelSelect.addEventListener('change', (e) => {
			mv.src = e.target.value;
			// reset progress UI
			barFill.style.width = '0%';
			progressPercent.textContent = '0%';
			progressText.textContent = 'Waiting to load...';
		});

		// Download for offline use
		downloadBtn.addEventListener('click', async () => {
			const modelUrl = modelSelect.value;
			if (!('caches' in window)) {
				alert('Caching not supported in this browser');
				return;
			}
			try {
				downloadBtn.disabled = true;
				downloadBtn.textContent = 'Downloading...';
				document.getElementById('cache-spinner').style.display = 'inline-block';
				document.getElementById('cache-status').textContent = 'Downloading — may take a minute';
				const cacheStatus = document.getElementById('cache-status');
				await fetchAndCacheWithProgress(modelUrl, (loaded, total) => {
					if (total) {
						const pct = Math.round((loaded / total) * 100);
						cacheStatus.textContent = `Downloading: ${pct}%`;
					} else {
						cacheStatus.textContent = `Downloading: ${Math.round(loaded / 1024)} KB`;
					}
				});
				cacheStatus.textContent = 'Download complete';
				document.getElementById('cache-spinner').style.display = 'none';
				document.getElementById('cache-status').textContent = 'Downloaded (available offline)';
				updateCacheIndicators();
			} catch (err) {
				console.error('Download+cache failed', err);
				alert('Download failed: ' + err.message);
			} finally {
				downloadBtn.disabled = false;
				downloadBtn.textContent = 'Download for offline use';
			}
		});

		// Remove downloaded model
		removeBtn.addEventListener('click', async () => {
			const modelUrl = modelSelect.value;
			if (!('serviceWorker' in navigator)) {
				alert('Service worker not supported in this browser');
				return;
			}
			try {
				const reg = await navigator.serviceWorker.ready;
				reg.active.postMessage({action: 'uncache-url', url: modelUrl});
				removeBtn.disabled = true;
				removeBtn.textContent = 'Removing...';
				document.getElementById('cache-spinner').style.display = 'inline-block';
				document.getElementById('cache-status').textContent = 'Removing cached file...';
			} catch (err) {
				console.error(err);
				alert('Failed to request removal');
			}
		});

		// Fetch and cache with streaming progress. Caches to the same cache name the SW uses.
		async function fetchAndCacheWithProgress(url, onProgress) {
			const CACHE_NAME = 'buildlab360-root-v1';
			const resp = await fetch(url);
			if (!resp.ok) throw new Error('Network response was not ok');
			// If there's no body (opaque), fallback to simple cache
			if (!resp.body) {
				const blob = await resp.blob();
				const newResp = new Response(blob, { headers: resp.headers });
				const cache = await caches.open(CACHE_NAME);
				await cache.put(url, newResp);
				return;
			}
			const contentLength = resp.headers.get('content-length') ? parseInt(resp.headers.get('content-length'), 10) : null;
			const reader = resp.body.getReader();
			const chunks = [];
			let received = 0;
			while (true) {
				const { done, value } = await reader.read();
				if (done) break;
				chunks.push(value);
				received += value.length || value.byteLength || 0;
				onProgress(received, contentLength);
			}
			const blob = new Blob(chunks);
			const newResp = new Response(blob, { headers: resp.headers });
			const cache = await caches.open(CACHE_NAME);
			await cache.put(url, newResp);
		}

		// FPS counter
		let lastFpsUpdate = performance.now();
		let frames = 0;
		function raf(now) {
			frames++;
			const delta = now - lastFpsUpdate;
			if (delta >= 500) { // update every 0.5s
				const fps = Math.round((frames / delta) * 1000);
				// update the overlay readout
				if (fpsOverlayEl) fpsOverlayEl.textContent = fps;
				frames = 0;
				lastFpsUpdate = now;
			}
			requestAnimationFrame(raf);
		}
		requestAnimationFrame(raf);

		// Register for service worker messages (confirmation)
		// Register the root service worker so caching works
		if ('serviceWorker' in navigator) {
			window.addEventListener('load', () => {
				navigator.serviceWorker.register('/backend/service-worker.js')
					.then(reg => console.log('✅ Root Service Worker registered from test:', reg.scope))
					.catch(err => console.error('❌ Root Service Worker registration failed (test):', err));
			});

			navigator.serviceWorker.addEventListener('message', (event) => {
				if (event.data && event.data.type === 'cache-complete') {
					console.log('SW cache complete', event.data.url);
					updateCacheIndicators();
				}
				if (event.data && event.data.type === 'uncache-complete') {
					console.log('SW uncache complete', event.data.url, 'removed=', event.data.removed);
					updateCacheIndicators();
					document.getElementById('cache-spinner').style.display = 'none';
					if (event.data.removed) alert('Removed cached model: ' + event.data.url);
				}
			});
		}

		// Utility: update cache indicators for each list item and the selected model
		async function updateCacheIndicators() {
			if (!('caches' in window)) return;
			const list = document.querySelectorAll('#cached-list li');
			for (const li of list) {
				const url = li.getAttribute('data-url');
				const match = await caches.match(url);
				const statusEl = li.querySelector('.status');
				if (match) {
					statusEl.textContent = '✅';
					statusEl.style.color = '#0f0';
				} else {
					statusEl.textContent = '⚪';
					statusEl.style.color = '#999';
				}
			}
			// update the single indicator next to dropdown
			const selectedUrl = modelSelect.value;
			const cacheIndicator = document.getElementById('cache-indicator');
			const selMatch = await caches.match(selectedUrl);
			if (selMatch) {
				cacheIndicator.textContent = '✅';
				cacheIndicator.style.color = '#0f0';
				// show remove button, hide download
				downloadBtn.style.display = 'none';
				removeBtn.style.display = 'inline-block';
				removeBtn.disabled = false;
				removeBtn.textContent = 'Remove downloaded';
			} else {
				cacheIndicator.textContent = '⚪';
				cacheIndicator.style.color = '#999';
				// show download button, hide remove
				downloadBtn.style.display = 'inline-block';
				downloadBtn.disabled = false;
				downloadBtn.textContent = 'Download for offline use';
				removeBtn.style.display = 'none';
			}
		}

		// call on load
		updateCacheIndicators();
	</script>
</body>
</html>

